// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import 'bridge/api.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'platform.dart';

/// Main entrypoint of the Rust API
class V8RayBridge
    extends
        BaseEntrypoint<V8RayBridgeApi, V8RayBridgeApiImpl, V8RayBridgeWire> {
  V8RayBridge._();
  @internal
  static final V8RayBridge instance = V8RayBridge._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    V8RayBridgeApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required V8RayBridgeApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<V8RayBridgeApiImpl, V8RayBridgeWire>
  get apiImplConstructor => V8RayBridgeApiImpl.new;

  @override
  WireConstructor<V8RayBridgeWire> get wireConstructor =>
      V8RayBridgeWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 1507415328;

  static const ExternalLibraryLoaderConfig kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'v8ray_core',
        ioDirectory: '../core/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class V8RayBridgeApi extends BaseApi {
  Future<String> crateBridgeApiAddSubscription({
    required String name,
    required String url,
  });

  Future<void> crateBridgeApiCacheProxyConfig({
    required String configId,
    required ProxyServerConfig config,
  });

  void crateBridgeApiClearSystemProxy();

  Future<void> crateBridgeApiConnect({required String configId});

  Future<void> crateBridgeApiDeleteConfig({required String configId});

  Future<void> crateBridgeApiDisconnect();

  Future<ConnectionInfo> crateBridgeApiGetConnectionInfo();

  PlatformInfo crateBridgeApiGetPlatformInfo();

  Future<ProxyServerConfig> crateBridgeApiGetServerConfig({
    required String serverId,
  });

  Future<List<ServerInfo>> crateBridgeApiGetServers();

  Future<List<ServerInfo>> crateBridgeApiGetServersForSubscription({
    required String subscriptionId,
  });

  Future<List<SubscriptionInfo>> crateBridgeApiGetSubscriptions();

  Future<TrafficStats> crateBridgeApiGetTrafficStats();

  bool crateBridgeApiHasAdminPrivileges();

  Future<void> crateBridgeApiInitSubscriptionManager({required String dbPath});

  Future<void> crateBridgeApiInitV8Ray();

  bool crateBridgeApiIsSystemProxySet();

  Future<List<ConfigInfo>> crateBridgeApiListConfigs();

  Future<ConfigInfo> crateBridgeApiLoadConfig({required String configId});

  Future<void> crateBridgeApiLoadSubscriptionsFromStorage();

  Future<void> crateBridgeApiRemoveSubscription({required String id});

  Future<void> crateBridgeApiResetTrafficStats();

  Future<void> crateBridgeApiSaveConfig({required ConfigInfo config});

  Future<void> crateBridgeApiSetProxyMode({required String mode});

  void crateBridgeApiSetSystemProxy({
    required int httpPort,
    required int socksPort,
  });

  Future<void> crateBridgeApiShutdownV8Ray();

  Future<int> crateBridgeApiTestLatency({required String configId});

  Future<void> crateBridgeApiUpdateAllSubscriptions();

  Future<void> crateBridgeApiUpdateSubscription({required String id});

  Future<bool> crateBridgeApiValidateConfig({required ConfigInfo config});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ValuePtr;
}

class V8RayBridgeApiImpl extends V8RayBridgeApiImplPlatform
    implements V8RayBridgeApi {
  V8RayBridgeApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> crateBridgeApiAddSubscription({
    required String name,
    required String url,
  }) => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_String(name, serializer);
        sse_encode_String(url, serializer);
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 1,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiAddSubscriptionConstMeta,
      argValues: <dynamic>[name, url],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiAddSubscriptionConstMeta =>
      const TaskConstMeta(
        debugName: 'add_subscription',
        argNames: <String>['name', 'url'],
      );

  @override
  Future<void> crateBridgeApiCacheProxyConfig({
    required String configId,
    required ProxyServerConfig config,
  }) => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_String(configId, serializer);
        sse_encode_box_autoadd_proxy_server_config(config, serializer);
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 2,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiCacheProxyConfigConstMeta,
      argValues: <dynamic>[configId, config],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiCacheProxyConfigConstMeta =>
      const TaskConstMeta(
        debugName: 'cache_proxy_config',
        argNames: <String>['configId', 'config'],
      );

  @override
  void crateBridgeApiClearSystemProxy() => handler.executeSync(
    SyncTask(
      callFfi: () {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeApiClearSystemProxyConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiClearSystemProxyConstMeta =>
      const TaskConstMeta(
        debugName: 'clear_system_proxy',
        argNames: <String>[],
      );

  @override
  Future<void> crateBridgeApiConnect({required String configId}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(configId, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 4,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiConnectConstMeta,
          argValues: <dynamic>[configId],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiConnectConstMeta =>
      const TaskConstMeta(debugName: 'connect', argNames: <String>['configId']);

  @override
  Future<void> crateBridgeApiDeleteConfig({required String configId}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(configId, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 5,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiDeleteConfigConstMeta,
          argValues: <dynamic>[configId],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiDeleteConfigConstMeta => const TaskConstMeta(
    debugName: 'delete_config',
    argNames: <String>['configId'],
  );

  @override
  Future<void> crateBridgeApiDisconnect() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 6,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiDisconnectConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiDisconnectConstMeta =>
      const TaskConstMeta(debugName: 'disconnect', argNames: <String>[]);

  @override
  Future<ConnectionInfo> crateBridgeApiGetConnectionInfo() =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 7,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_connection_info,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiGetConnectionInfoConstMeta,
          argValues: <dynamic>[],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiGetConnectionInfoConstMeta =>
      const TaskConstMeta(
        debugName: 'get_connection_info',
        argNames: <String>[],
      );

  @override
  PlatformInfo crateBridgeApiGetPlatformInfo() => handler.executeSync(
    SyncTask(
      callFfi: () {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_platform_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateBridgeApiGetPlatformInfoConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiGetPlatformInfoConstMeta =>
      const TaskConstMeta(debugName: 'get_platform_info', argNames: <String>[]);

  @override
  Future<ProxyServerConfig> crateBridgeApiGetServerConfig({
    required String serverId,
  }) => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_String(serverId, serializer);
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 9,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_proxy_server_config,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiGetServerConfigConstMeta,
      argValues: <dynamic>[serverId],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiGetServerConfigConstMeta =>
      const TaskConstMeta(
        debugName: 'get_server_config',
        argNames: <String>['serverId'],
      );

  @override
  Future<List<ServerInfo>> crateBridgeApiGetServers() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 10,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_server_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiGetServersConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiGetServersConstMeta =>
      const TaskConstMeta(debugName: 'get_servers', argNames: <String>[]);

  @override
  Future<List<ServerInfo>> crateBridgeApiGetServersForSubscription({
    required String subscriptionId,
  }) => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_String(subscriptionId, serializer);
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 11,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_server_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiGetServersForSubscriptionConstMeta,
      argValues: <dynamic>[subscriptionId],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiGetServersForSubscriptionConstMeta =>
      const TaskConstMeta(
        debugName: 'get_servers_for_subscription',
        argNames: <String>['subscriptionId'],
      );

  @override
  Future<List<SubscriptionInfo>> crateBridgeApiGetSubscriptions() =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 12,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_list_subscription_info,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiGetSubscriptionsConstMeta,
          argValues: <dynamic>[],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiGetSubscriptionsConstMeta =>
      const TaskConstMeta(debugName: 'get_subscriptions', argNames: <String>[]);

  @override
  Future<TrafficStats> crateBridgeApiGetTrafficStats() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 13,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_traffic_stats,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiGetTrafficStatsConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiGetTrafficStatsConstMeta =>
      const TaskConstMeta(debugName: 'get_traffic_stats', argNames: <String>[]);

  @override
  bool crateBridgeApiHasAdminPrivileges() => handler.executeSync(
    SyncTask(
      callFfi: () {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeApiHasAdminPrivilegesConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiHasAdminPrivilegesConstMeta =>
      const TaskConstMeta(
        debugName: 'has_admin_privileges',
        argNames: <String>[],
      );

  @override
  Future<void> crateBridgeApiInitSubscriptionManager({
    required String dbPath,
  }) => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_String(dbPath, serializer);
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 15,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiInitSubscriptionManagerConstMeta,
      argValues: <dynamic>[dbPath],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiInitSubscriptionManagerConstMeta =>
      const TaskConstMeta(
        debugName: 'init_subscription_manager',
        argNames: <String>['dbPath'],
      );

  @override
  Future<void> crateBridgeApiInitV8Ray() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 16,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiInitV8RayConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiInitV8RayConstMeta =>
      const TaskConstMeta(debugName: 'init_v8ray', argNames: <String>[]);

  @override
  bool crateBridgeApiIsSystemProxySet() => handler.executeSync(
    SyncTask(
      callFfi: () {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeApiIsSystemProxySetConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiIsSystemProxySetConstMeta =>
      const TaskConstMeta(
        debugName: 'is_system_proxy_set',
        argNames: <String>[],
      );

  @override
  Future<List<ConfigInfo>> crateBridgeApiListConfigs() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 18,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_config_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiListConfigsConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiListConfigsConstMeta =>
      const TaskConstMeta(debugName: 'list_configs', argNames: <String>[]);

  @override
  Future<ConfigInfo> crateBridgeApiLoadConfig({required String configId}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(configId, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 19,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_config_info,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiLoadConfigConstMeta,
          argValues: <dynamic>[configId],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiLoadConfigConstMeta => const TaskConstMeta(
    debugName: 'load_config',
    argNames: <String>['configId'],
  );

  @override
  Future<void> crateBridgeApiLoadSubscriptionsFromStorage() =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 20,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiLoadSubscriptionsFromStorageConstMeta,
          argValues: <dynamic>[],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiLoadSubscriptionsFromStorageConstMeta =>
      const TaskConstMeta(
        debugName: 'load_subscriptions_from_storage',
        argNames: <String>[],
      );

  @override
  Future<void> crateBridgeApiRemoveSubscription({required String id}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(id, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 21,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiRemoveSubscriptionConstMeta,
          argValues: <dynamic>[id],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiRemoveSubscriptionConstMeta =>
      const TaskConstMeta(
        debugName: 'remove_subscription',
        argNames: <String>['id'],
      );

  @override
  Future<void> crateBridgeApiResetTrafficStats() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 22,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiResetTrafficStatsConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiResetTrafficStatsConstMeta =>
      const TaskConstMeta(
        debugName: 'reset_traffic_stats',
        argNames: <String>[],
      );

  @override
  Future<void> crateBridgeApiSaveConfig({required ConfigInfo config}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_box_autoadd_config_info(config, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 23,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiSaveConfigConstMeta,
          argValues: <dynamic>[config],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiSaveConfigConstMeta => const TaskConstMeta(
    debugName: 'save_config',
    argNames: <String>['config'],
  );

  @override
  Future<void> crateBridgeApiSetProxyMode({required String mode}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(mode, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 24,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiSetProxyModeConstMeta,
          argValues: <dynamic>[mode],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiSetProxyModeConstMeta => const TaskConstMeta(
    debugName: 'set_proxy_mode',
    argNames: <String>['mode'],
  );

  @override
  void crateBridgeApiSetSystemProxy({
    required int httpPort,
    required int socksPort,
  }) => handler.executeSync(
    SyncTask(
      callFfi: () {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        sse_encode_u_16(httpPort, serializer);
        sse_encode_u_16(socksPort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_String,
      ),
      constMeta: kCrateBridgeApiSetSystemProxyConstMeta,
      argValues: <dynamic>[httpPort, socksPort],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiSetSystemProxyConstMeta =>
      const TaskConstMeta(
        debugName: 'set_system_proxy',
        argNames: <String>['httpPort', 'socksPort'],
      );

  @override
  Future<void> crateBridgeApiShutdownV8Ray() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 26,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiShutdownV8RayConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiShutdownV8RayConstMeta =>
      const TaskConstMeta(debugName: 'shutdown_v8ray', argNames: <String>[]);

  @override
  Future<int> crateBridgeApiTestLatency({required String configId}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(configId, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 27,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_u_32,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiTestLatencyConstMeta,
          argValues: <dynamic>[configId],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiTestLatencyConstMeta => const TaskConstMeta(
    debugName: 'test_latency',
    argNames: <String>['configId'],
  );

  @override
  Future<void> crateBridgeApiUpdateAllSubscriptions() => handler.executeNormal(
    NormalTask(
      callFfi: (NativePortType port_) {
        final SseSerializer serializer = SseSerializer(
          generalizedFrbRustBinding,
        );
        pdeCallFfi(
          generalizedFrbRustBinding,
          serializer,
          funcId: 28,
          port: port_,
        );
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBridgeApiUpdateAllSubscriptionsConstMeta,
      argValues: <dynamic>[],
      apiImpl: this,
    ),
  );

  TaskConstMeta get kCrateBridgeApiUpdateAllSubscriptionsConstMeta =>
      const TaskConstMeta(
        debugName: 'update_all_subscriptions',
        argNames: <String>[],
      );

  @override
  Future<void> crateBridgeApiUpdateSubscription({required String id}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_String(id, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 29,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_unit,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiUpdateSubscriptionConstMeta,
          argValues: <dynamic>[id],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiUpdateSubscriptionConstMeta =>
      const TaskConstMeta(
        debugName: 'update_subscription',
        argNames: <String>['id'],
      );

  @override
  Future<bool> crateBridgeApiValidateConfig({required ConfigInfo config}) =>
      handler.executeNormal(
        NormalTask(
          callFfi: (NativePortType port_) {
            final SseSerializer serializer = SseSerializer(
              generalizedFrbRustBinding,
            );
            sse_encode_box_autoadd_config_info(config, serializer);
            pdeCallFfi(
              generalizedFrbRustBinding,
              serializer,
              funcId: 30,
              port: port_,
            );
          },
          codec: SseCodec(
            decodeSuccessData: sse_decode_bool,
            decodeErrorData: sse_decode_AnyhowException,
          ),
          constMeta: kCrateBridgeApiValidateConfigConstMeta,
          argValues: <dynamic>[config],
          apiImpl: this,
        ),
      );

  TaskConstMeta get kCrateBridgeApiValidateConfigConstMeta =>
      const TaskConstMeta(
        debugName: 'validate_config',
        argNames: <String>['config'],
      );

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

  @protected
  AnyhowException dco_decode_AnyhowException(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Value
  dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, Value>
  dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
    raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
      dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
        raw,
      ).map(((String, Value) e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Value
  dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ConfigInfo dco_decode_box_autoadd_config_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config_info(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  ProxyServerConfig dco_decode_box_autoadd_proxy_server_config(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_proxy_server_config(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ConfigInfo dco_decode_config_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return ConfigInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      server: dco_decode_String(arr[2]),
      port: dco_decode_u_16(arr[3]),
      protocol: dco_decode_String(arr[4]),
      enabled: dco_decode_bool(arr[5]),
      createdAt: dco_decode_i_64(arr[6]),
      updatedAt: dco_decode_i_64(arr[7]),
    );
  }

  @protected
  ConnectionInfo dco_decode_connection_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ConnectionInfo(
      status: dco_decode_connection_status(arr[0]),
      serverAddress: dco_decode_opt_String(arr[1]),
      duration: dco_decode_u_64(arr[2]),
      uploadBytes: dco_decode_u_64(arr[3]),
      downloadBytes: dco_decode_u_64(arr[4]),
      latencyMs: dco_decode_opt_box_autoadd_u_32(arr[5]),
    );
  }

  @protected
  ConnectionStatus dco_decode_connection_status(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ConnectionStatus.values[raw as int];
  }

  @protected
  int dco_decode_i_32(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<String> dco_decode_list_String(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ConfigInfo> dco_decode_list_config_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_config_info).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, Value)>
  dco_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
          dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value,
        )
        .toList();
  }

  @protected
  List<ServerInfo> dco_decode_list_server_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_server_info).toList();
  }

  @protected
  List<SubscriptionInfo> dco_decode_list_subscription_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subscription_info).toList();
  }

  @protected
  String? dco_decode_opt_String(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  PlatformCapabilities dco_decode_platform_capabilities(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PlatformCapabilities(
      systemProxy: dco_decode_bool(arr[0]),
      vpnMode: dco_decode_bool(arr[1]),
      tunMode: dco_decode_bool(arr[2]),
      autoStart: dco_decode_bool(arr[3]),
    );
  }

  @protected
  PlatformInfo dco_decode_platform_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return PlatformInfo(
      os: dco_decode_String(arr[0]),
      arch: dco_decode_String(arr[1]),
      version: dco_decode_String(arr[2]),
      capabilities: dco_decode_platform_capabilities(arr[3]),
    );
  }

  @protected
  ProxyServerConfig dco_decode_proxy_server_config(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return ProxyServerConfig(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      address: dco_decode_String(arr[2]),
      port: dco_decode_u_16(arr[3]),
      protocol: dco_decode_String(arr[4]),
      settings:
          dco_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
            arr[5],
          ),
      tags: dco_decode_list_String(arr[6]),
    );
  }

  @protected
  (String, Value)
  dco_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
        arr[1],
      ),
    );
  }

  @protected
  ServerInfo dco_decode_server_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ServerInfo(
      id: dco_decode_String(arr[0]),
      subscriptionId: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      address: dco_decode_String(arr[3]),
      port: dco_decode_i_32(arr[4]),
      protocol: dco_decode_String(arr[5]),
    );
  }

  @protected
  SubscriptionInfo dco_decode_subscription_info(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return SubscriptionInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      url: dco_decode_String(arr[2]),
      lastUpdate: dco_decode_opt_box_autoadd_i_64(arr[3]),
      serverCount: dco_decode_i_32(arr[4]),
      status: dco_decode_String(arr[5]),
    );
  }

  @protected
  TrafficStats dco_decode_traffic_stats(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final List<dynamic> arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return TrafficStats(
      uploadSpeed: dco_decode_u_64(arr[0]),
      downloadSpeed: dco_decode_u_64(arr[1]),
      totalUpload: dco_decode_u_64(arr[2]),
      totalDownload: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  int dco_decode_u_16(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Value
  sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ValueImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  Map<String, Value>
  sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final List<(String, Value)> inner =
        sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
          deserializer,
        );
    return Map.fromEntries(
      inner.map(((String, Value) e) => MapEntry(e.$1, e.$2)),
    );
  }

  @protected
  Value
  sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ValueImpl.frbInternalSseDecode(
      sse_decode_usize(deserializer),
      sse_decode_i_32(deserializer),
    );
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final Uint8List inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  ConfigInfo sse_decode_box_autoadd_config_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_config_info(deserializer);
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_i_64(deserializer);
  }

  @protected
  ProxyServerConfig sse_decode_box_autoadd_proxy_server_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_proxy_server_config(deserializer);
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return sse_decode_u_32(deserializer);
  }

  @protected
  ConfigInfo sse_decode_config_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_id = sse_decode_String(deserializer);
    final String var_name = sse_decode_String(deserializer);
    final String var_server = sse_decode_String(deserializer);
    final int var_port = sse_decode_u_16(deserializer);
    final String var_protocol = sse_decode_String(deserializer);
    final bool var_enabled = sse_decode_bool(deserializer);
    final PlatformInt64 var_createdAt = sse_decode_i_64(deserializer);
    final PlatformInt64 var_updatedAt = sse_decode_i_64(deserializer);
    return ConfigInfo(
      id: var_id,
      name: var_name,
      server: var_server,
      port: var_port,
      protocol: var_protocol,
      enabled: var_enabled,
      createdAt: var_createdAt,
      updatedAt: var_updatedAt,
    );
  }

  @protected
  ConnectionInfo sse_decode_connection_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final ConnectionStatus var_status = sse_decode_connection_status(
      deserializer,
    );
    final String? var_serverAddress = sse_decode_opt_String(deserializer);
    final BigInt var_duration = sse_decode_u_64(deserializer);
    final BigInt var_uploadBytes = sse_decode_u_64(deserializer);
    final BigInt var_downloadBytes = sse_decode_u_64(deserializer);
    final int? var_latencyMs = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ConnectionInfo(
      status: var_status,
      serverAddress: var_serverAddress,
      duration: var_duration,
      uploadBytes: var_uploadBytes,
      downloadBytes: var_downloadBytes,
      latencyMs: var_latencyMs,
    );
  }

  @protected
  ConnectionStatus sse_decode_connection_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final int inner = sse_decode_i_32(deserializer);
    return ConnectionStatus.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final int len_ = sse_decode_i_32(deserializer);
    final List<String> ans_ = <String>[];
    for (int idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ConfigInfo> sse_decode_list_config_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final int len_ = sse_decode_i_32(deserializer);
    final List<ConfigInfo> ans_ = <ConfigInfo>[];
    for (int idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_config_info(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final int len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, Value)>
  sse_decode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final int len_ = sse_decode_i_32(deserializer);
    final List<(String, Value)> ans_ = <(String, Value)>[];
    for (int idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
        sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
          deserializer,
        ),
      );
    }
    return ans_;
  }

  @protected
  List<ServerInfo> sse_decode_list_server_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final int len_ = sse_decode_i_32(deserializer);
    final List<ServerInfo> ans_ = <ServerInfo>[];
    for (int idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_server_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<SubscriptionInfo> sse_decode_list_subscription_info(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    final int len_ = sse_decode_i_32(deserializer);
    final List<SubscriptionInfo> ans_ = <SubscriptionInfo>[];
    for (int idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subscription_info(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_String(deserializer);
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_i_64(deserializer);
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return sse_decode_box_autoadd_u_32(deserializer);
    } else {
      return null;
    }
  }

  @protected
  PlatformCapabilities sse_decode_platform_capabilities(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final bool var_systemProxy = sse_decode_bool(deserializer);
    final bool var_vpnMode = sse_decode_bool(deserializer);
    final bool var_tunMode = sse_decode_bool(deserializer);
    final bool var_autoStart = sse_decode_bool(deserializer);
    return PlatformCapabilities(
      systemProxy: var_systemProxy,
      vpnMode: var_vpnMode,
      tunMode: var_tunMode,
      autoStart: var_autoStart,
    );
  }

  @protected
  PlatformInfo sse_decode_platform_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_os = sse_decode_String(deserializer);
    final String var_arch = sse_decode_String(deserializer);
    final String var_version = sse_decode_String(deserializer);
    final PlatformCapabilities var_capabilities =
        sse_decode_platform_capabilities(deserializer);
    return PlatformInfo(
      os: var_os,
      arch: var_arch,
      version: var_version,
      capabilities: var_capabilities,
    );
  }

  @protected
  ProxyServerConfig sse_decode_proxy_server_config(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_id = sse_decode_String(deserializer);
    final String var_name = sse_decode_String(deserializer);
    final String var_address = sse_decode_String(deserializer);
    final int var_port = sse_decode_u_16(deserializer);
    final String var_protocol = sse_decode_String(deserializer);
    final Map<String, Value> var_settings =
        sse_decode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
          deserializer,
        );
    final List<String> var_tags = sse_decode_list_String(deserializer);
    return ProxyServerConfig(
      id: var_id,
      name: var_name,
      address: var_address,
      port: var_port,
      protocol: var_protocol,
      settings: var_settings,
      tags: var_tags,
    );
  }

  @protected
  (String, Value)
  sse_decode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_field0 = sse_decode_String(deserializer);
    final Value var_field1 =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          deserializer,
        );
    return (var_field0, var_field1);
  }

  @protected
  ServerInfo sse_decode_server_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_id = sse_decode_String(deserializer);
    final String var_subscriptionId = sse_decode_String(deserializer);
    final String var_name = sse_decode_String(deserializer);
    final String var_address = sse_decode_String(deserializer);
    final int var_port = sse_decode_i_32(deserializer);
    final String var_protocol = sse_decode_String(deserializer);
    return ServerInfo(
      id: var_id,
      subscriptionId: var_subscriptionId,
      name: var_name,
      address: var_address,
      port: var_port,
      protocol: var_protocol,
    );
  }

  @protected
  SubscriptionInfo sse_decode_subscription_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final String var_id = sse_decode_String(deserializer);
    final String var_name = sse_decode_String(deserializer);
    final String var_url = sse_decode_String(deserializer);
    final PlatformInt64? var_lastUpdate = sse_decode_opt_box_autoadd_i_64(
      deserializer,
    );
    final int var_serverCount = sse_decode_i_32(deserializer);
    final String var_status = sse_decode_String(deserializer);
    return SubscriptionInfo(
      id: var_id,
      name: var_name,
      url: var_url,
      lastUpdate: var_lastUpdate,
      serverCount: var_serverCount,
      status: var_status,
    );
  }

  @protected
  TrafficStats sse_decode_traffic_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    final BigInt var_uploadSpeed = sse_decode_u_64(deserializer);
    final BigInt var_downloadSpeed = sse_decode_u_64(deserializer);
    final BigInt var_totalUpload = sse_decode_u_64(deserializer);
    final BigInt var_totalDownload = sse_decode_u_64(deserializer);
    return TrafficStats(
      uploadSpeed: var_uploadSpeed,
      downloadSpeed: var_downloadSpeed,
      totalUpload: var_totalUpload,
      totalDownload: var_totalDownload,
    );
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
  sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    Value self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
      (self as ValueImpl).frbInternalSseEncode(move: true),
      serializer,
    );
  }

  @protected
  void
  sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
    Map<String, Value> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
      self.entries
          .map((MapEntry<String, Value> e) => (e.key, e.value))
          .toList(),
      serializer,
    );
  }

  @protected
  void
  sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
    Value self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize((self as ValueImpl).frbInternalSseEncode(), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_config_info(
    ConfigInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
    PlatformInt64 self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_proxy_server_config(
    ProxyServerConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_proxy_server_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_config_info(ConfigInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.server, serializer);
    sse_encode_u_16(self.port, serializer);
    sse_encode_String(self.protocol, serializer);
    sse_encode_bool(self.enabled, serializer);
    sse_encode_i_64(self.createdAt, serializer);
    sse_encode_i_64(self.updatedAt, serializer);
  }

  @protected
  void sse_encode_connection_info(
    ConnectionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_connection_status(self.status, serializer);
    sse_encode_opt_String(self.serverAddress, serializer);
    sse_encode_u_64(self.duration, serializer);
    sse_encode_u_64(self.uploadBytes, serializer);
    sse_encode_u_64(self.downloadBytes, serializer);
    sse_encode_opt_box_autoadd_u_32(self.latencyMs, serializer);
  }

  @protected
  void sse_encode_connection_status(
    ConnectionStatus self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final String item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_config_info(
    List<ConfigInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final ConfigInfo item in self) {
      sse_encode_config_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void
  sse_encode_list_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    List<(String, Value)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final (String, Value) item in self) {
      sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
        item,
        serializer,
      );
    }
  }

  @protected
  void sse_encode_list_server_info(
    List<ServerInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final ServerInfo item in self) {
      sse_encode_server_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_subscription_info(
    List<SubscriptionInfo> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final SubscriptionInfo item in self) {
      sse_encode_subscription_info(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
    PlatformInt64? self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_platform_capabilities(
    PlatformCapabilities self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.systemProxy, serializer);
    sse_encode_bool(self.vpnMode, serializer);
    sse_encode_bool(self.tunMode, serializer);
    sse_encode_bool(self.autoStart, serializer);
  }

  @protected
  void sse_encode_platform_info(PlatformInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.os, serializer);
    sse_encode_String(self.arch, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_platform_capabilities(self.capabilities, serializer);
  }

  @protected
  void sse_encode_proxy_server_config(
    ProxyServerConfig self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_u_16(self.port, serializer);
    sse_encode_String(self.protocol, serializer);
    sse_encode_Map_String_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue_None(
      self.settings,
      serializer,
    );
    sse_encode_list_String(self.tags, serializer);
  }

  @protected
  void
  sse_encode_record_string_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_value(
    (String, Value) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
      self.$2,
      serializer,
    );
  }

  @protected
  void sse_encode_server_info(ServerInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.subscriptionId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.address, serializer);
    sse_encode_i_32(self.port, serializer);
    sse_encode_String(self.protocol, serializer);
  }

  @protected
  void sse_encode_subscription_info(
    SubscriptionInfo self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_i_64(self.lastUpdate, serializer);
    sse_encode_i_32(self.serverCount, serializer);
    sse_encode_String(self.status, serializer);
  }

  @protected
  void sse_encode_traffic_stats(TrafficStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.uploadSpeed, serializer);
    sse_encode_u_64(self.downloadSpeed, serializer);
    sse_encode_u_64(self.totalUpload, serializer);
    sse_encode_u_64(self.totalDownload, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class ValueImpl extends RustOpaque implements Value {
  // Not to be used by end users
  ValueImpl.frbInternalDcoDecode(List<dynamic> wire)
    : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ValueImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
    : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final RustArcStaticData<dynamic> _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        V8RayBridge.instance.api.rust_arc_increment_strong_count_Value,
    rustArcDecrementStrongCount:
        V8RayBridge.instance.api.rust_arc_decrement_strong_count_Value,
    rustArcDecrementStrongCountPtr:
        V8RayBridge.instance.api.rust_arc_decrement_strong_count_ValuePtr,
  );
}
